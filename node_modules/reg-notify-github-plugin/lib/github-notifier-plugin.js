"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitHubNotifierPlugin = void 0;
const path_1 = __importDefault(require("path"));
const tiny_commit_walker_1 = require("tiny-commit-walker");
const zlib_1 = require("zlib");
const reg_gh_app_interface_1 = require("reg-gh-app-interface");
const reg_suit_util_1 = require("reg-suit-util");
const undici_1 = require("undici");
function isGhAppError(x) {
    return x.name && x.name === "StatusCodeError";
}
const errorHandler = (logger) => {
    return (reason) => {
        if (isGhAppError(reason)) {
            logger.error(reason.error.message);
            return Promise.reject(reason.error);
        }
        else {
            return Promise.reject(reason);
        }
    };
};
class GitHubNotifierPlugin {
    _decodeClientId(clientId) {
        const tmp = (0, zlib_1.inflateRawSync)(new Buffer(clientId, "base64")).toString().split("/");
        if (tmp.length !== 4) {
            this._logger.error(`Invalid client ID: ${this._logger.colors.red(clientId)}`);
            throw new Error(`Invalid client ID: ${clientId}`);
        }
        const [repository, installationId, owner] = tmp.slice(1);
        return { repository, installationId, owner };
    }
    init(config) {
        var _a, _b;
        this._noEmit = config.noEmit;
        this._logger = config.logger;
        if (config.options.clientId) {
            this._apiOpt = this._decodeClientId(config.options.clientId);
        }
        else {
            this._apiOpt = config.options;
        }
        this._prComment = config.options.prComment !== false;
        this._behavior = (_a = config.options.prCommentBehavior) !== null && _a !== void 0 ? _a : "default";
        this._setCommitStatus = config.options.setCommitStatus !== false;
        this._shortDescription = (_b = config.options.shortDescription) !== null && _b !== void 0 ? _b : false;
        this._apiPrefix = config.options.customEndpoint || (0, reg_gh_app_interface_1.getGhAppInfo)().endpoint;
        this._repo = new tiny_commit_walker_1.Repository(path_1.default.join(reg_suit_util_1.fsUtil.prjRootDir(".git"), ".git"));
    }
    notify(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const head = this._repo.readHeadSync();
            const { failedItems, newItems, deletedItems, passedItems } = params.comparisonResult;
            const failedItemsCount = failedItems.length;
            const newItemsCount = newItems.length;
            const deletedItemsCount = deletedItems.length;
            const passedItemsCount = passedItems.length;
            const state = failedItemsCount + newItemsCount + deletedItemsCount === 0 ? "success" : "failure";
            const description = state === "success" ? "Regression testing passed" : "Regression testing failed";
            let sha1;
            if (head.branch) {
                sha1 = head.branch.commit.hash;
            }
            else if (head.commit) {
                sha1 = head.commit.hash;
            }
            else {
                this._logger.error("Can't detect HEAD branch or commit.");
                return Promise.resolve();
            }
            const updateStatusBody = Object.assign(Object.assign({}, this._apiOpt), { sha1,
                description,
                state });
            if (params.reportUrl)
                updateStatusBody.reportUrl = params.reportUrl;
            if (this._prComment) {
                updateStatusBody.metadata = {
                    failedItemsCount,
                    newItemsCount,
                    deletedItemsCount,
                    passedItemsCount,
                    shortDescription: this._shortDescription,
                };
            }
            const reqs = [];
            if (this._setCommitStatus) {
                const statusReq = {
                    url: `${this._apiPrefix}/api/update-status`,
                    method: "POST",
                    body: updateStatusBody,
                };
                this._logger.info(`Update status for ${this._logger.colors.green(updateStatusBody.sha1)} .`);
                this._logger.verbose("update-status: ", statusReq);
                reqs.push(statusReq);
            }
            if (this._prComment) {
                if (head.type === "branch" && head.branch) {
                    const prCommentBody = Object.assign(Object.assign({}, this._apiOpt), { behavior: this._behavior, branchName: head.branch.name, headOid: sha1, failedItemsCount,
                        newItemsCount,
                        deletedItemsCount,
                        passedItemsCount, shortDescription: this._shortDescription });
                    if (params.reportUrl)
                        prCommentBody.reportUrl = params.reportUrl;
                    const commentReq = {
                        url: `${this._apiPrefix}/api/comment-to-pr`,
                        method: "POST",
                        body: prCommentBody,
                    };
                    this._logger.info(`Comment to PR associated with ${this._logger.colors.green(prCommentBody.branchName)} .`);
                    this._logger.verbose("PR comment: ", commentReq);
                    reqs.push(commentReq);
                }
                else {
                    this._logger.warn(`HEAD is not attached into any branches.`);
                }
            }
            if (this._noEmit) {
                return Promise.resolve();
            }
            const spinner = this._logger.getSpinner("sending notification to GitHub...");
            spinner.start();
            return Promise.all(reqs.map((req) => __awaiter(this, void 0, void 0, function* () {
                try {
                    const res = yield (0, undici_1.fetch)(req.url, {
                        method: req.method,
                        body: JSON.stringify(req.body),
                    });
                    if (400 <= res.status) {
                        throw new Error(`HTTP ${res.status}: Failed to request.`);
                    }
                }
                catch (err) {
                    const handler = errorHandler(this._logger);
                    yield handler(err);
                }
            })))
                .then(() => spinner.stop())
                .catch(() => spinner.stop());
        });
    }
}
exports.GitHubNotifierPlugin = GitHubNotifierPlugin;
//# sourceMappingURL=github-notifier-plugin.js.map