"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegProcessor = void 0;
const path_1 = __importDefault(require("path"));
const rimraf_1 = require("rimraf");
const copy_image_sync_1 = require("./copy-image-sync");
const compare = require("reg-cli");
class RegProcessor {
    constructor(opt) {
        this._logger = opt.logger;
        this._config = opt.coreConfig;
        this._directoryInfo = {
            workingDirs: opt.workingDirs,
            userDirs: opt.options.userDirs,
        };
        this._keyGenerator = opt.options.keyGenerator;
        this._publisher = opt.options.publisher;
        this._notifiers = opt.options.notifiers;
    }
    runAll() {
        return this.getExpectedKey()
            .then(ctx => this.syncExpected(ctx))
            .then(ctx => this.compare(ctx))
            .then(ctx => this.getActualKey(ctx))
            .then(ctx => this.publish(ctx))
            .then(ctx => this.notify(ctx));
    }
    getExpectedKey() {
        if (this._keyGenerator) {
            return this._keyGenerator
                .getExpectedKey()
                .then(key => {
                this._logger.info(`Detected the previous snapshot key: '${key}'`);
                return { expectedKey: key };
            })
                .catch(reason => {
                this._logger.warn("Failed to detect the previous snapshot key");
                if (reason)
                    this._logger.error(reason);
                return Promise.resolve({ expectedKey: null });
            });
        }
        else {
            this._logger.info("Skipped to detect the previous snapshot key because key generator plugin is not set up.");
            return Promise.resolve({ expectedKey: null });
        }
    }
    compare(ctx) {
        var _a;
        const { actualDir, expectedDir, diffDir } = this._directoryInfo.workingDirs;
        const json = path_1.default.join(this._directoryInfo.workingDirs.base, "out.json");
        const report = path_1.default.join(this._directoryInfo.workingDirs.base, "index.html");
        const ximgdiffConf = this._config.ximgdiff || { invocationType: "cli" };
        (0, rimraf_1.rimrafSync)(actualDir);
        (0, copy_image_sync_1.copyImagesSync)(this._directoryInfo.userDirs.actualDir, actualDir);
        const emitter = compare({
            actualDir,
            expectedDir,
            diffDir,
            json,
            report,
            update: false,
            ignoreChange: true,
            urlPrefix: "",
            threshold: this._config.threshold,
            thresholdPixel: this._config.thresholdPixel,
            thresholdRate: this._config.thresholdRate,
            matchingThreshold: (_a = this._config.matchingThreshold) !== null && _a !== void 0 ? _a : 0,
            enableAntialias: this._config.enableAntialias,
            enableCliAdditionalDetection: ximgdiffConf.invocationType === "cli",
            enableClientAdditionalDetection: ximgdiffConf.invocationType !== "none",
        });
        emitter.on("compare", (compareItem) => {
            this._logger.verbose(`${this._logger.colors.red(compareItem.type)}: ${this._logger.colors.magenta(compareItem.path)}`);
        });
        const comparisonResult = new Promise((resolve, reject) => {
            emitter.once("complete", (result) => resolve(result));
            emitter.once("error", (reason) => reject(reason));
        });
        return comparisonResult
            .then(result => {
            this._logger.info("Comparison Complete");
            this._logger.info(this._logger.colors.red("   Changed items: " + result.failedItems.length));
            this._logger.info(this._logger.colors.cyan("   New items: " + result.newItems.length));
            this._logger.info(this._logger.colors.redBright("   Deleted items: " + result.deletedItems.length));
            this._logger.info(this._logger.colors.green("   Passed items: " + result.passedItems.length));
            this._logger.verbose("Comparison details:", result);
            return Object.assign(Object.assign({}, ctx), { comparisonResult: result });
        })
            .catch(reason => {
            // re-throw notifiers error because it's fatal.
            this._logger.error("An error occurs during compare images:");
            if (reason)
                this._logger.error(reason);
            return Promise.reject(reason);
        });
    }
    getActualKey(ctx) {
        const fallbackFn = () => "snapshot_" + ~~(new Date().getTime() / 1000);
        if (this._keyGenerator) {
            return this._keyGenerator
                .getActualKey()
                .then(key => {
                if (!key) {
                    this._logger.warn("Failed to generate the current snapshot key.");
                    return Object.assign(Object.assign({}, ctx), { actualKey: fallbackFn() });
                }
                this._logger.info(`The current snapshot key: '${key}'`);
                return Object.assign(Object.assign({}, ctx), { actualKey: key });
            })
                .catch(reason => {
                this._logger.warn("Failed to gerenate the current snapshot key.");
                if (reason)
                    this._logger.error(reason);
                return Promise.resolve(Object.assign(Object.assign({}, ctx), { actualKey: fallbackFn() }));
            });
        }
        else {
            const fallbackKey = fallbackFn();
            this._logger.info(`Use '${fallbackKey}' as the current snapshot key because key generator plugin is not set up.`);
            return Promise.resolve(Object.assign(Object.assign({}, ctx), { actualKey: fallbackKey }));
        }
    }
    syncExpected(ctx) {
        const keyForExpected = ctx.expectedKey;
        if (this._publisher && keyForExpected) {
            return this._publisher.fetch(keyForExpected);
        }
        else if (!keyForExpected) {
            this._logger.info("Skipped to fetch the expected data because expected key is null.");
            return Promise.resolve(ctx);
        }
        else if (!this._publisher) {
            this._logger.info("Skipped to fetch the expected data because publisher plugin is not set up.");
            return Promise.resolve(ctx);
        }
        else {
            return Promise.resolve(ctx);
        }
    }
    publish(ctx) {
        if (this._publisher) {
            return this._publisher
                .publish(ctx.actualKey)
                .then(result => {
                this._logger.info(`Published snapshot '${ctx.actualKey}' successfully.`);
                if (result.reportUrl) {
                    this._logger.info(`Report URL: ${result.reportUrl}`);
                }
                this._logger.verbose("Publish result:", result);
                return Object.assign(Object.assign({}, ctx), { reportUrl: result.reportUrl });
            })
                .catch(reason => {
                // re-throw notifiers error because it's fatal.
                this._logger.error("An error occurs during publishing snapshot:");
                if (reason.code === "CredentialsError") {
                    this._logger.error("Failed to read AWS credentials.");
                    this._logger.error(`Create ${this._logger.colors.magenta("~/.aws/credentials")} or export ${this._logger.colors.green("$AWS_ACCESS_KEY_ID")} and ${this._logger.colors.green("$AWS_SECRET_ACCESS_KEY")}.`);
                }
                if (reason)
                    this._logger.error(reason);
                return Promise.reject(reason);
            });
        }
        else {
            this._logger.info("Skipped to publish the snapshot data because publisher plugin is not set up.");
            return Promise.resolve(ctx);
        }
    }
    notify(ctx) {
        const notifyParams = Object.assign({}, ctx);
        if (!this._notifiers.length) {
            this._logger.info("Skipped to notify result because notifier plugins are not set up.");
        }
        this._logger.verbose("Notify parameters:", notifyParams);
        return this._notifiers
            .reduce((queue, notifier) => {
            return queue
                .then(() => notifier.notify(notifyParams))
                .catch(reason => {
                // Don't re-throw notifiers error because it's not fatal.
                this._logger.error("An error occurs during notify:");
                this._logger.error(reason);
                return Promise.resolve();
            });
        }, Promise.resolve())
            .then(() => ctx);
    }
}
exports.RegProcessor = RegProcessor;
//# sourceMappingURL=processor.js.map