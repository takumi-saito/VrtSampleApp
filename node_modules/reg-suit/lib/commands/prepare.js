"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareCore = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const inquirer_1 = __importDefault(require("inquirer"));
const ignore_1 = __importDefault(require("ignore"));
const package_util_1 = __importStar(require("../package-util"));
const get_reg_core_1 = __importDefault(require("../get-reg-core"));
function hasGitignore(dir) {
    return fs_1.default.existsSync(path_1.default.resolve(dir, ".gitignore"));
}
function loadGitignore(dir) {
    const gi = fs_1.default.readFileSync(path_1.default.resolve(dir, ".gitignore"), "utf8");
    const ig = (0, ignore_1.default)();
    gi.split("\n").forEach(l => {
        if (!l.trim().startsWith("#")) {
            ig.add(l);
        }
    });
    return ig;
}
function appendGitignore(dir, name) {
    fs_1.default.appendFileSync(path_1.default.resolve(dir, ".gitignore"), name + "\n", "utf-8");
}
function prepareCore(coreConf, confDir) {
    return inquirer_1.default
        .prompt([
        {
            name: "workingDir",
            message: "Working directory of reg-suit.",
            default: coreConf.workingDir,
            validate(x) {
                return !!x.length;
            },
        },
        {
            name: "addIgnore",
            type: "confirm",
            message: function ({ workingDir }) {
                return `Append "${workingDir}" entry to your .gitignore file.`;
            },
            when({ workingDir }) {
                return hasGitignore(confDir) && !loadGitignore(confDir).ignores(workingDir);
            },
            default: true,
        },
        {
            name: "actualDir",
            message: "Directory contains actual images.",
            default: coreConf.actualDir,
            validate(x) {
                return !!x.length;
            },
        },
        {
            name: "thresholdRate",
            message: "Threshold, ranges from 0 to 1. Smaller value makes the comparison more sensitive.",
            default: coreConf.thresholdRate || coreConf.threshold || "0",
            validate(x) {
                return !!x.length;
            },
        },
    ])
        .then((conf) => {
        if (conf.addIgnore) {
            appendGitignore(confDir, conf.workingDir);
        }
        return Object.assign(Object.assign({}, conf), { thresholdRate: +conf.thresholdRate, ximgdiff: {
                invocationType: "client",
            } });
    });
}
exports.prepareCore = prepareCore;
function prepare(options, willPrepareCore = false) {
    willPrepareCore = willPrepareCore && !options.plugins.length;
    const core = (0, get_reg_core_1.default)(options, true);
    const installedPluginNames = package_util_1.default.getInstalledPlugins();
    let pluginNames = [];
    if (options.plugins.length) {
        options.plugins.forEach(name => {
            const pluginName = package_util_1.PLUGIN_NAME_REGEXP.test(name) ? name : `reg-${name}-plugin`;
            if (!installedPluginNames.some(p => p === pluginName)) {
                core.logger.warn(`Plugin '${pluginName}' is not installed. Please exec 'npm install ${pluginName}' .`);
            }
            else {
                pluginNames.push(pluginName);
            }
        });
    }
    else {
        pluginNames = installedPluginNames;
    }
    const confirmUpdateConfig = () => inquirer_1.default
        .prompt([
        {
            name: "result",
            message: "Update configuration file",
            type: "confirm",
            default: true,
        },
    ])
        .then(({ result }) => result);
    return (willPrepareCore ? prepareCore(core.config.core, core.getDirectoryInfo().prjDir) : Promise.resolve(core.config.core))
        .then(coreConfig => {
        const questions = core.createQuestions({ pluginNames });
        return questions
            .reduce((acc, qh) => {
            return acc.then(configs => {
                if (qh.questions.length) {
                    core.logger.info(`Set up ${qh.name}:`);
                }
                const additionalQuestion = !!qh.configured
                    ? () => inquirer_1.default.prompt([
                        {
                            name: "override",
                            type: "confirm",
                            message: `${qh.name} has been already configured. Override this configuration`,
                            default: false,
                        },
                    ])
                    : () => Promise.resolve({ override: true });
                return additionalQuestion()
                    .then(({ override }) => {
                    if (override) {
                        return inquirer_1.default.prompt(qh.questions).then((ans) => qh.prepare(ans));
                    }
                    else {
                        return Promise.resolve(qh.configured);
                    }
                })
                    .then((c) => [...configs, { name: qh.name, config: c }]);
            });
        }, Promise.resolve([]))
            .then((pluginConfigs) => ({ core: coreConfig, pluginConfigs }));
    })
        .then(newConf => core.persistMergedConfig(newConf, confirmUpdateConfig));
}
exports.default = prepare;
//# sourceMappingURL=prepare.js.map